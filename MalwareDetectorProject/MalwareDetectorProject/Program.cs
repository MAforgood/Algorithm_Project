/*
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Threading.Tasks;

namespace MalwareDetectorProject
{
    class Program
    {
        static void Main(string[] args)
        {
            string addrespath = @"C:\Users\Mohammad\OneDrive\Desktop\mm";
            string[] malwarefiles = Directory.GetFiles(addrespath);
            string longestCommonSubstring = FindLCS(malwarefiles);

            Console.WriteLine("Longest common substring: " + longestCommonSubstring);
            Console.ReadKey();
        }
        private static string FindLCS(string[] files)
        {
            string commonsubstring = ReadFileContent(files[0]);
            for (int i = 1; i < files.Length; i++)
            {
                string current = ReadFileContent(files[i]);
                commonsubstring = LCS(commonsubstring, current);
            }
            return commonsubstring;
        }
        private static string ReadFileContent(string path)
        {
            return File.ReadAllText(path);
        }
        private static string LCS(string str1, string str2)
        {
            int m = str1.Length;
            int n = str2.Length;

            int[,] dp = new int[m + 1, n + 1];

            // Build the dynamic programming table
            for (int i = 1; i <= m; i++)
            {
                for (int j = 1; j <= n; j++)
                {
                    if (str1[i - 1] == str2[j - 1])
                        dp[i, j] = dp[i - 1, j - 1] + 1;
                    else
                        dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
                }
            }

            // Construct the longest common subsequence
            int index = dp[m, n];
            char[] lcs = new char[index];
            int x = m, y = n;
            while (x > 0 && y > 0)
            {
                if (str1[x - 1] == str2[y - 1])
                {
                    lcs[index - 1] = str1[x - 1];
                    x--;
                    y--;
                    index--;
                }
                else if (dp[x - 1, y] > dp[x, y - 1])
                    x--;
                else
                    y--;
            }

            return new string(lcs);
        }
        
    }
}
        */

/*
using System;
using System.IO;
using System.Text;

namespace MalwareDetectorProject
{
  class Program
  {
      static void Main(string[] args)
      {
          string addressPath = @"C:\Users\Mohammad\Downloads\Released\Released\Train\Malware Sample\20";
          string[] malwareFiles = Directory.GetFiles(addressPath,"*",SearchOption.AllDirectories);

          // Apply LCS algorithm to find common substrings
          string longestCommonSubstring = FindLCS(malwareFiles);
          Console.WriteLine("PreProcess Done!");

          Console.WriteLine("Longest common substring: " + longestCommonSubstring.Length);
          Console.ReadKey();
      }

      private static string FindLCS(string[] files)
      {
          string commonSubstring = string.Empty;

          foreach (string file in files)
          {
              string currentSubstring = ReadFileContent(file);
              commonSubstring = LCS(commonSubstring, currentSubstring);
          }

          return commonSubstring;
      }

      private static string ReadFileContent(string path)
      {
          StringBuilder contentBuilder = new StringBuilder();

          using (FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read))
          using (StreamReader reader = new StreamReader(fileStream))
          {
              string line;
              while ((line = reader.ReadLine()) != null)
              {
                  contentBuilder.Append(line);
              }
          }

          return contentBuilder.ToString();
      }

      private static string LCS(string str1, string str2)
      {
          int m = str1.Length;
          int n = str2.Length;

          int[,] dp = new int[m + 1, n + 1];

          // Build the dynamic programming table
          for (int i = 1; i <= m; i++)
          {
              for (int j = 1; j <= n; j++)
              {
                  if (str1[i - 1] == str2[j - 1])
                      dp[i, j] = dp[i - 1, j - 1] + 1;
                  else
                      dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
              }
          }

          // Construct the longest common subsequence
          int index = dp[m, n];
          char[] lcs = new char[index];
          int x = m - 1, y = n - 1; // Fix the indexing here
          while (x >= 0 && y >= 0) // Fix the condition here
          {
              if (str1[x] == str2[y]) // Fix the indexing here
              {
                  lcs[index - 1] = str1[x]; // Fix the indexing here
                  x--;
                  y--;
                  index--;
              }
              else if (dp[x, y + 1] > dp[x + 1, y]) // Fix the indexing here
                  x--;
              else
                  y--;
          }

          return new string(lcs);
      }

  }
}
*/

/*
using System;
using System.IO;
using System.Text;

namespace MalwareDetectorProject
{
    class Program
    {
        static void Main(string[] args)
        {
            string directoryPath = @"C:\Users\Mohammad\OneDrive\Desktop\mm";

            try
            {
                string[] malwareFiles = Directory.GetFiles(directoryPath,"*",SearchOption.AllDirectories);

                foreach (string file in malwareFiles)
                {
                   // Console.WriteLine("File: " + file);
                    string fileContent = ReadFileContent(file);
                  //  Console.WriteLine("Content: " + fileContent);
                    Console.WriteLine();
                }

                string longestCommonSubstring = FindLCS(malwareFiles);
                Console.WriteLine("Longest common substring: " + longestCommonSubstring);

                Console.ReadLine();
               
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error: " + ex.Message);
            }

            Console.ReadLine();
        }

        private static string FindLCS(string[] files)
        {
            if (files.Length == 0)
                return string.Empty;

            string commonSubstring = ReadFileContent(files[0]);

            for (int i = 1; i < files.Length; i++)
            {
                string currentFileContent = ReadFileContent(files[i]);
                commonSubstring = LCS(commonSubstring, currentFileContent);
            }

            return commonSubstring;
        }

        private static string ReadFileContent(string path)
        {
            try
            {
                byte[] fileBytes = File.ReadAllBytes(path);
                StringBuilder hexBuilder = new StringBuilder();

                foreach (byte b in fileBytes)
                {
                    hexBuilder.Append(b.ToString("X2"));
                    hexBuilder.Append(" ");
                }

                return hexBuilder.ToString().Trim();
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error reading file: " + ex.Message);
                return string.Empty;
            }
        }

        private static string LCS(string str1, string str2)
        {
            int m = str1.Length;
            int n = str2.Length;

            int[,] dp = new int[m + 1, n + 1];

            // Build the dynamic programming table
            for (int i = 1; i <= m; i++)
            {
                for (int j = 1; j <= n; j++)
                {
                    if (str1[i - 1] == str2[j - 1])
                        dp[i, j] = dp[i - 1, j - 1] + 1;
                    else
                        dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
                }
            }

            // Construct the longest common subsequence
            int index = dp[m, n];
            char[] lcs = new char[index];
            int x = m - 1, y = n - 1;
            while (x >= 0 && y >= 0)
            {
                if (str1[x] == str2[y])
                {
                    lcs[index - 1] = str1[x];
                    x--;
                    y--;
                    index--;
                }
                else if (dp[x, y + 1] > dp[x + 1, y])
                    x--;
                else
                    y--;
            }

            return new string(lcs);
        }
    }
}
*/

/*
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace MalwareDetectorProject
{
    class Program
    {
        static void Main(string[] args)
        {
            string baseFilePath = @"C:\Users\Mohammad\OneDrive\Desktop\mm\2 (2)";
            string malwareFilesPath = @"C:\Users\Mohammad\Downloads\Released\Released\Train\Malware Sample";

            string[] malwareFiles = Directory.GetFiles(malwareFilesPath, "*", SearchOption.AllDirectories);

            // Read the base file contents
            byte[] baseFileBytes = File.ReadAllBytes(baseFilePath);

            // Find patterns in each malware file
            foreach (string malwareFile in malwareFiles)
            {
                byte[] malwareBytes = File.ReadAllBytes(malwareFile);

                List<byte[]> commonSequences = FindCommonSequences(baseFileBytes, malwareBytes);

                Console.WriteLine("File: " + malwareFile);
                Console.WriteLine("Common Sequences:");

                foreach (byte[] sequence in commonSequences)
                {
                    string hexSequence = BitConverter.ToString(sequence).Replace("-", " ");
                    Console.WriteLine(hexSequence);
                }

                Console.WriteLine();
            }

            Console.ReadLine();
        }

        private static List<byte[]> FindCommonSequences(byte[] bytes1, byte[] bytes2)
        {
            int[,] dp = new int[bytes1.Length + 1, bytes2.Length + 1];

            // Build the dynamic programming table
            for (int i = 1; i <= bytes1.Length; i++)
            {
                for (int j = 1; j <= bytes2.Length; j++)
                {
                    if (bytes1[i - 1] == bytes2[j - 1])
                        dp[i, j] = dp[i - 1, j - 1] + 1;
                    else
                        dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
                }
            }

            // Trace back to find the common sequences
            int length = dp[bytes1.Length, bytes2.Length];
            List<byte[]> commonSequences = new List<byte[]>();

            TraceBack(dp, bytes1, bytes2, bytes1.Length, bytes2.Length, length, new byte[length], commonSequences);

            return commonSequences;
        }

        private static void TraceBack(int[,] dp, byte[] bytes1, byte[] bytes2, int i, int j, int length, byte[] sequence, List<byte[]> commonSequences)
        {
            if (i == 0 || j == 0)
            {
                if (length > 0)
                {
                    byte[] commonSequence = new byte[length];
                    Array.Copy(sequence, commonSequence, length);
                    Array.Reverse(commonSequence);
                    commonSequences.Add(commonSequence);
                }
                return;
            }

            if (bytes1[i - 1] == bytes2[j - 1])
            {
                sequence[length - 1] = bytes1[i - 1];
                TraceBack(dp, bytes1, bytes2, i - 1, j - 1, length - 1, sequence, commonSequences);
            }
            else
            {
                if (dp[i - 1, j] > dp[i, j - 1])
                    TraceBack(dp, bytes1, bytes2, i - 1, j, length, sequence, commonSequences);
                else
                    TraceBack(dp, bytes1, bytes2, i, j - 1, length, sequence, commonSequences);
            }
        }
    }
}
*/

/*
using System;
using System.Collections.Generic;
using System.IO;

namespace MalwareDetectorProject
{
    class Program
    {
        static void Main(string[] args)
        {
            string baseFilePath = @"C:\Users\Mohammad\OneDrive\Desktop\mm\2 (2)";
            string malwareFilesPath = @"C:\Users\Mohammad\OneDrive\Desktop\New folder";

            string[] malwareFiles = Directory.GetFiles(malwareFilesPath, "*", SearchOption.AllDirectories);

            // Read the base file contents
            byte[] baseFileBytes = File.ReadAllBytes(baseFilePath);

            // Find patterns in each malware file
            foreach (string malwareFile in malwareFiles)
            {
                byte[] malwareBytes = File.ReadAllBytes(malwareFile);
                Console.WriteLine("test");
                List<byte[]> commonSequences = FindCommonSequences(baseFileBytes, malwareBytes);
                Console.WriteLine("test");
                //Console.WriteLine("File: " + malwareFile);
                Console.WriteLine("Common Sequences:");

                foreach (byte[] sequence in commonSequences)
                {
                    string hexSequence = BitConverter.ToString(sequence).Replace("-", " ");
                    Console.WriteLine(hexSequence);
                }

                Console.WriteLine();
            }
           
            Console.ReadLine();
        }

        private static List<byte[]> FindCommonSequences(byte[] bytes1, byte[] bytes2)
        {
            int[][] dp = new int[2][];

            // Initialize the rolling array
            for (int i = 0; i < 2; i++)
                dp[i] = new int[bytes2.Length + 1];

            int currentRow = 0;
            int previousRow = 1;

            // Build the dynamic programming table
            for (int i = 1; i <= bytes1.Length; i++)
            {
                currentRow = i % 2;
                previousRow = 1 - currentRow;

                for (int j = 1; j <= bytes2.Length; j++)
                {
                    if (bytes1[i - 1] == bytes2[j - 1])
                        dp[currentRow][j] = dp[previousRow][j - 1] + 1;
                    else
                        dp[currentRow][j] = Math.Max(dp[previousRow][j], dp[currentRow][j - 1]);
                }
            }

            // Trace back to find the common sequences
            int length = dp[currentRow][bytes2.Length];
            List<byte[]> commonSequences = new List<byte[]>();

            byte[] sequence = new byte[length];
            int index = length - 1;
            currentRow = bytes1.Length % 2;
            int iRow = bytes1.Length;

            for (int j = bytes2.Length; j > 0 && length > 0; j--)
            {
                if (bytes1[iRow - 1] == bytes2[j - 1] && dp[currentRow][j] == length)
                {
                    sequence[index] = bytes1[iRow - 1];
                    index--;
                    length--;
                    iRow--;
                }
                else if (dp[currentRow][j] < length)
                {
                    iRow--;
                }
            }

            if (index == -1 && length == 0)
                commonSequences.Add(sequence);

            return commonSequences;
        }
    }
}
*/

/*

using System;
using System.Collections.Generic;
using System.IO;

namespace MalwareDetectorProject
{
    class Program
    {
        static void Main(string[] args)
        {
            string baseFilePath = @"C:\Users\Mohammad\OneDrive\Desktop\mm\2 (2)";
            string malwareFilesPath = @"C:\Users\Mohammad\OneDrive\Desktop\New folder";

            string[] malwareFiles = Directory.GetFiles(malwareFilesPath, "*", SearchOption.AllDirectories);

            // Read the base file contents
            byte[] baseFileBytes = File.ReadAllBytes(baseFilePath);

            // Find patterns in each malware file
            foreach (string malwareFile in malwareFiles)
            {
                byte[] malwareBytes = File.ReadAllBytes(malwareFile);

                List<byte[]> commonSequences = FindCommonSequences(baseFileBytes, malwareBytes);

                Console.WriteLine("File: " + malwareFile);
                Console.WriteLine("Common Sequences:");

                foreach (byte[] sequence in commonSequences)
                {
                    string hexSequence = BitConverter.ToString(sequence).Replace("-", " ");
                    Console.WriteLine(hexSequence);
                }

                Console.WriteLine();
            }

            Console.ReadLine();
        }

        private static List<byte[]> FindCommonSequences(byte[] bytes1, byte[] bytes2)
        {
            int chunkSize =100* 1024 * 1024; // 1MB chunk size (adjust as needed)
            List<byte[]> commonSequences = new List<byte[]>();

            for (int offset1 = 0; offset1 < bytes1.Length; offset1 += chunkSize)
            {
                int length1 = Math.Min(chunkSize, bytes1.Length - offset1);
                byte[] chunk1 = new byte[length1];
                Buffer.BlockCopy(bytes1, offset1, chunk1, 0, length1);

                for (int offset2 = 0; offset2 < bytes2.Length; offset2 += chunkSize)
                {
                    int length2 = Math.Min(chunkSize, bytes2.Length - offset2);
                    byte[] chunk2 = new byte[length2];
                    Buffer.BlockCopy(bytes2, offset2, chunk2, 0, length2);

                    List<byte[]> chunkSequences = FindCommonSequencesInChunks(chunk1, chunk2);
                    commonSequences.AddRange(chunkSequences);
                }
            }

            return commonSequences;
        }

        private static List<byte[]> FindCommonSequencesInChunks(byte[] chunk1, byte[] chunk2)
        {
            int[,] dp = new int[chunk1.Length + 1, chunk2.Length + 1];

            // Build the dynamic programming table
            for (int i = 1; i <= chunk1.Length; i++)
            {
                for (int j = 1; j <= chunk2.Length; j++)
                {
                    if (chunk1[i - 1] == chunk2[j - 1])
                        dp[i, j] = dp[i - 1, j - 1] + 1;
                    else
                        dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
                }
            }

            // Trace back to find the common sequences
            int length = dp[chunk1.Length, chunk2.Length];
            List<byte[]> commonSequences = new List<byte[]>();

            byte[] sequence = new byte[length];
            int index = length - 1;
            int iRow = chunk1.Length;
            int jCol = chunk2.Length;

            while (iRow > 0 && jCol > 0)
            {
                if (chunk1[iRow - 1] == chunk2[jCol - 1])
                {
                    sequence[index] = chunk1[iRow - 1];
                    index--;
                    length--;
                    iRow--;
                    jCol--;
                }
                else if (dp[iRow - 1, jCol] > dp[iRow, jCol - 1])
                {
                    iRow--;
                }
                else
                {
                    jCol--;
                }

                if (length == 0)
                {
                    commonSequences.Add(sequence);
                    if (index >= 0)
                        sequence = new byte[length = dp[iRow, jCol]];
                    index = length - 1;
                }
            }

            return commonSequences;
        }
    }
}
*/

/*
using System;
using System.Collections.Generic;
using System.IO;

namespace MalwareDetectorProject
{
    class Program
    {
        static void Main(string[] args)
        {
            string baseFilePath = @"C:\Users\Mohammad\OneDrive\Desktop\mm\2 (2)";
            string malwareFilesPath = @"C:\Users\Mohammad\OneDrive\Desktop\New folder";

            string[] malwareFiles = Directory.GetFiles(malwareFilesPath, "*", SearchOption.AllDirectories);

            // Read the base file contents
            byte[] baseFileBytes = File.ReadAllBytes(baseFilePath);

            // Find patterns in each malware file
            foreach (string malwareFile in malwareFiles)
            {
                byte[] malwareBytes = File.ReadAllBytes(malwareFile);

               // List<byte[]> commonSequences = FindCommonSequences(baseFileBytes, malwareBytes);

                Console.WriteLine("File: " + malwareFile);
                Console.WriteLine("Common Sequences:");

                foreach (byte[] sequence in commonSequences)
                {
                    string hexSequence = BitConverter.ToString(sequence).Replace("-", " ");
                    string stringSequence = HexToString(hexSequence);
                    Console.WriteLine(stringSequence);
                }

                Console.WriteLine();
            }

            Console.ReadLine();
        }

        private static List<byte[]> FindCommonSequences(byte[] bytes1, byte[] bytes2)
        {
            int[][] dp = new int[2][];

            // Initialize the rolling array
            for (int i = 0; i < 2; i++)
                dp[i] = new int[bytes2.Length + 1];

            int currentRow = 0;
            int previousRow = 1;

            // Build the dynamic programming table
            for (int i = 1; i <= bytes1.Length; i++)
            {
                currentRow = i % 2;
                previousRow = 1 - currentRow;

                for (int j = 1; j <= bytes2.Length; j++)
                {
                    if (bytes1[i - 1] == bytes2[j - 1])
                        dp[currentRow][j] = dp[previousRow][j - 1] + 1;
                    else
                        dp[currentRow][j] = Math.Max(dp[previousRow][j], dp[currentRow][j - 1]);
                }
            }

            // Trace back to find the common sequences
            int length = dp[currentRow][bytes2.Length];
            List<byte[]> commonSequences = new List<byte[]>();

            byte[] sequence = new byte[length];
            int index = length - 1;
            currentRow = bytes1.Length % 2;
            int iRow = bytes1.Length;

            for (int j = bytes2.Length; j > 0 && length > 0; j--)
            {
                if (bytes1[iRow - 1] == bytes2[j - 1] && dp[currentRow][j] == length)
                {
                    sequence[index] = bytes1[iRow - 1];
                    index--;
                    length--;
                    iRow--;
                }
                else if (dp[currentRow][j] < length)
                {
                    iRow--;
                }
            }

            if (index == -1 && length == 0)
                commonSequences.Add(sequence);

            return commonSequences;
        }

        private static string HexToString(string hex)
        {
            string[] hexArray = hex.Split(' ');
            byte[] byteArray = new byte[hexArray.Length];

            for (int i = 0; i < hexArray.Length; i++)
            {
                byteArray[i] = Convert.ToByte(hexArray[i], 16);
            }

            return System.Text.Encoding.ASCII.GetString(byteArray);
        }
    }
}
*/

/*
using System;
using System.Collections.Generic;
using System.IO;

namespace MalwareDetectorProject
{
    class Program
    {
        private static string HexToString(string hex)
        {
            string[] hexArray = hex.Split(' ');
            byte[] byteArray = new byte[hexArray.Length];

            for (int i = 0; i < hexArray.Length; i++)
            {
                byteArray[i] = Convert.ToByte(hexArray[i], 16);
            }

            return System.Text.Encoding.ASCII.GetString(byteArray);
        }
        static void Main(string[] args)
        {
            string baseFilePath = @"C:\Users\Mohammad\OneDrive\Desktop\mm\2 (2)";
            string malwareFilesPath = @"C:\Users\Mohammad\OneDrive\Desktop\New folder";

            string[] malwareFiles = Directory.GetFiles(malwareFilesPath, "*", SearchOption.AllDirectories);

            // Read the base file contents
            string baseFileContent = ConvertFileToHexString(baseFilePath);

            // Find patterns in each malware file
            foreach (string malwareFile in malwareFiles)
            {
                string malwareContent = ConvertFileToHexString(malwareFile);
                string tmp = HexToString(malwareContent);

                List<string> commonSequences = FindCommonSequences(baseFileContent, malwareContent);
                Console.WriteLine(tmp);
                Console.WriteLine("File: " + malwareFile);
                Console.WriteLine("Common Sequences:");

                foreach (string sequence in commonSequences)
                {
                    Console.WriteLine(sequence);
                }

                Console.WriteLine();
            }

            Console.ReadLine();
        }

        private static string ConvertFileToHexString(string filePath)
        {
            byte[] fileBytes = File.ReadAllBytes(filePath);
            string hexString = BitConverter.ToString(fileBytes).Replace("-", " ");
            return hexString;
        }

        private static List<string> FindCommonSequences(string text1, string text2)
        {
            // Implement the logic for finding common sequences in the string content
            // ... (LCS algorithm or any other pattern matching algorithm)

            // Placeholder code
            List<string> commonSequences = new List<string>();
            commonSequences.Add("Sample Common Sequence 1");
            commonSequences.Add("Sample Common Sequence 2");

            return commonSequences;
        }
    }
}
*/

/*
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace MalwareDetectorProject
{
    class Program
    {
        static void Main(string[] args)
        {
            string baseFilePath = @"C:\Users\Mohammad\OneDrive\Desktop\mm\2 (2)";
            string malwareFilesPath = @"C:\Users\Mohammad\OneDrive\Desktop\New folder";

            string[] malwareFiles = Directory.GetFiles(malwareFilesPath, "*", SearchOption.AllDirectories);

            // Define the value of n for n-grams
            int n = 4;

            // Extract n-grams from the base file
            List<string> baseFileNGrams = ExtractNGramsFromFile(baseFilePath, n);

            // Find patterns in each malware file
            foreach (string malwareFile in malwareFiles)
            {
                List<string> malwareFileNGrams = ExtractNGramsFromFile(malwareFile, n);

                // Find common n-grams between the base file and malware file
                List<string> commonNGrams = FindCommonNGrams(baseFileNGrams, malwareFileNGrams);

                Console.WriteLine("File: " + malwareFile);
                Console.WriteLine("Common NGrams:");

                foreach (string ngram in commonNGrams)
                {
                    Console.WriteLine(ngram);
                }

                Console.WriteLine();
            }

            Console.ReadLine();
        }

        private static List<string> ExtractNGramsFromFile(string filePath, int n)
        {
            byte[] fileBytes = File.ReadAllBytes(filePath);

            List<string> ngrams = new List<string>();

            for (int i = 0; i <= fileBytes.Length - n; i++)
            {
                byte[] ngramBytes = fileBytes.Skip(i).Take(n).ToArray();
                string ngram = BitConverter.ToString(ngramBytes).Replace("-", " ");
                ngrams.Add(ngram);
            }

            return ngrams;
        }

        private static List<string> FindCommonNGrams(List<string> baseNGrams, List<string> malwareNGrams)
        {
            // Find common n-grams between the base file and malware file
            List<string> commonNGrams = baseNGrams.Intersect(malwareNGrams).ToList();

            return commonNGrams;
        }
    }
}
*/


/*
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace MalwareDetectorProject
{
    class Program
    {
        static void Main(string[] args)
        {
            string baseFilePath = @"C:\Users\Mohammad\OneDrive\Desktop\mm\2 (2)";
            string malwareFilesPath = @"C:\Users\Mohammad\Downloads\Released\Released\Train\Malware Sample\2";

            string[] malwareFiles = Directory.GetFiles(malwareFilesPath, "*", SearchOption.AllDirectories);

            // Define the value of n for n-grams
            int n =32;

            // Extract n-grams from the base file
            List<string> baseFileNGrams = ExtractNGramsFromFile(baseFilePath, n);
            Console.WriteLine("First extract done");

            // Find patterns in each malware file
            foreach (string malwareFile in malwareFiles)
            {
                List<string> malwareFileNGrams = ExtractNGramsFromFile(malwareFile, n);

                // Find common n-grams between the base file and malware file
                List<string> commonNGrams = FindCommonNGrams(baseFileNGrams, malwareFileNGrams);

                Console.WriteLine("File: " + malwareFile);
                Console.WriteLine("Common NGrams:");

                foreach (string ngram in commonNGrams)
                {
                    string asciiString = HexToAscii(ngram);
                    Console.WriteLine(asciiString);
                }

                Console.WriteLine();
            }

            Console.WriteLine("end");
            Console.ReadLine();
        }

        private static List<string> ExtractNGramsFromFile(string filePath, int n)
        {
            byte[] fileBytes = File.ReadAllBytes(filePath);

            List<string> ngrams = new List<string>();

            for (int i = 0; i <= fileBytes.Length - n; i++)
            {
                byte[] ngramBytes = fileBytes.Skip(i).Take(n).ToArray();
                string ngram = BitConverter.ToString(ngramBytes).Replace("-", " ");
                ngrams.Add(ngram);
            }

            return ngrams;
        }

        private static List<string> FindCommonNGrams(List<string> baseNGrams, List<string> malwareNGrams)
        {
            // Find common n-grams between the base file and malware file
            List<string> commonNGrams = baseNGrams.Intersect(malwareNGrams).ToList();

            return commonNGrams;
        }

        private static string HexToAscii(string hex)
        {
            string[] hexValues = hex.Split(' ');
            StringBuilder sb = new StringBuilder();

            foreach (string hexValue in hexValues)
            {
                if (byte.TryParse(hexValue, System.Globalization.NumberStyles.HexNumber, null, out byte asciiValue))
                {
                    sb.Append((char)asciiValue);
                }
            }

            return sb.ToString();
        }
    }
}
*/
/*

using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        int cnt = 0;
        // Provide the directory path containing the files to check
        string directoryPath = @"C:\Users\Mohammad\Downloads\Released\Released\Train\Malware Sample";

        // Get all files in the directory
        string[] filePaths = Directory.GetFiles(directoryPath,"*",SearchOption.AllDirectories);

        Parallel.ForEach(filePaths, filePath =>
        {
            bool isMalware = CheckFileForMalware(filePath);
            if (isMalware)
            {
                 Console.WriteLine($"File '{filePath}' contains the malware pattern. It may be malicious.");
                cnt++;
            }
            else
            {
                Console.WriteLine($"File '{filePath}' safe.");
            }
            
        });
        Console.WriteLine(cnt);
        Console.ReadLine();
    }

    
    static bool CheckFileForMalware(string filePath)
    {
        // Read the file as hex string
        string hexString = ReadFileAsHexString(filePath);

        // Convert hex string to ASCII string
        string content = HexToString(hexString);

        // Define the malware pattern
        //string malwarePattern = "0123456789abcdefghijklmnopqrstuvwxyz";
        string[] malwarePatterns =
         {
           

        //  "PADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDIN",


        //"<requestedExecutionLevel level=",

        
         "[Dziadulja Apanas]",
         "vectorcall",
         "will not function properly",
          "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
          "Rekmmm",
          "½@{÷1¬/\"%",
          "Nfg1QfL4Qd%5Th",
          "W2LPA",
          "%08x_ipc",
          @"HARDWARE\DESCRIPTION\System\CentralProcessor",
          "645FF040-5081-101B-9F08-00AA002F954E",
           "UDx",
        "0123456789abcdefghijklmnopqrstuvwxyz",
        //"MSVBVM60",
         "AVbad_array_new_length",
        "PEAUZipMemChain",
        "Srv.exe",
        "<dependency><dependentAssembly>",
         "Delphi-the best. Fuck off all the rest. Neshta 1.0 Made in Belarus",
         "Best regards 2 Tommy Salo",

       // "!\"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
        //"PADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDIN",
       // "publicKeyToken=\"6595b64144ccf1df\"",
         //"AVexception",
        //"AVbad_alloc@std@@",
       // "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        
    };

        // Check if any of the patterns exist in the content
        bool isMalware = false;
        foreach (string pattern in malwarePatterns)
        {
            if (content.Contains(pattern))
            {
                isMalware = true;
                break;
            }
        }
        return isMalware;
    }
    
    static string ReadFileAsHexString(string filePath)
    {
        using (FileStream fileStream = File.OpenRead(filePath))
        {
            byte[] buffer = new byte[fileStream.Length];
            fileStream.Read(buffer, 0, buffer.Length);

            // Convert bytes to hex string
            string hexString = BitConverter.ToString(buffer).Replace("-", "");

            return hexString;
        }

    }



static string HexToString(string hexString)
    {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < hexString.Length; i += 2)
        {
            string hexPair = hexString.Substring(i, 2);
            byte b = Convert.ToByte(hexPair, 16);
            sb.Append((char)b);
        }

        return sb.ToString();
    }
}
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MalwareDetectorProject
{
    class Program
    {
        static void Main(string[] args)
        {
            string baseFilePath = @"C:\Users\Mohammad\OneDrive\Desktop\7 (95)";
            string malwareFilesPath = @"C:\Users\Mohammad\OneDrive\Desktop\New folder";

            string[] malwareFiles = Directory.GetFiles(malwareFilesPath, "*", SearchOption.AllDirectories);

            // Define the value of n for n-grams
            int n = 32;

            // Extract n-grams from the base file
            List<string> baseFileNGrams = ExtractNGramsFromFile(baseFilePath, n);
            Console.WriteLine("First extract done");

            // Process malware files in parallel
            Parallel.ForEach(malwareFiles, malwareFile =>
            {
                List<string> malwareFileNGrams = ExtractNGramsFromFile(malwareFile, n);

                // Find common n-grams between the base file and malware file
                List<string> commonNGrams = FindCommonNGrams(baseFileNGrams, malwareFileNGrams);

                Console.WriteLine("File: " + malwareFile);
                Console.WriteLine("Common NGrams:");

                foreach (string ngram in commonNGrams)
                {
                    string asciiString = HexToAscii(ngram);
                    Console.WriteLine(asciiString);
                }

                Console.WriteLine();
            });

            Console.WriteLine("End");
            Console.ReadLine();
        }

        private static List<string> ExtractNGramsFromFile(string filePath, int n)
        {
            byte[] fileBytes = File.ReadAllBytes(filePath);

            List<string> ngrams = new List<string>();

            for (int i = 0; i <= fileBytes.Length - n; i++)
            {
                byte[] ngramBytes = fileBytes.Skip(i).Take(n).ToArray();
                string ngram = BitConverter.ToString(ngramBytes).Replace("-", " ");
                ngrams.Add(ngram);
            }

            return ngrams;
        }

        private static List<string> FindCommonNGrams(List<string> baseNGrams, List<string> malwareNGrams)
        {
            // Find common n-grams between the base file and malware file
            List<string> commonNGrams = baseNGrams.Intersect(malwareNGrams).ToList();

            return commonNGrams;
        }

        private static string HexToAscii(string hex)
        {
            string[] hexValues = hex.Split(' ');
            StringBuilder sb = new StringBuilder();

            foreach (string hexValue in hexValues)
            {
                if (byte.TryParse(hexValue, System.Globalization.NumberStyles.HexNumber, null, out byte asciiValue))
                {
                    sb.Append((char)asciiValue);
                }
            }

            return sb.ToString();
        }
    }
}



using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        int cnt = 0;
        string directoryPath = @"C:\Users\Mohammad\OneDrive\Desktop\New folder";
        string malwareFolderPath = @"C:\Users\Mohammad\OneDrive\Desktop\Temp\Malwares";
        string safeFolderPath = @"C:\Users\Mohammad\OneDrive\Desktop\Temp\Safe";
        string[] filePaths = Directory.GetFiles(directoryPath, "*", SearchOption.AllDirectories);

        Parallel.ForEach(filePaths, filePath =>
        {
            bool isMalware = CheckFileForMalware(filePath);
            if (isMalware)
            {
                string destinationFolder = Path.Combine(malwareFolderPath, Path.GetFileName(filePath));
                Directory.CreateDirectory(malwareFolderPath);
                Directory.CreateDirectory(destinationFolder);
                File.Copy(filePath, Path.Combine(destinationFolder, Path.GetFileName(filePath)), true);
               // Console.WriteLine($"File '{filePath}' contains the malware pattern. It may be malicious.");
                cnt++;
            }
            else
            {
                string destinationFolder = Path.Combine(safeFolderPath, Path.GetFileName(filePath));
                Directory.CreateDirectory(safeFolderPath);
                Directory.CreateDirectory(destinationFolder);
                File.Copy(filePath, Path.Combine(destinationFolder, Path.GetFileName(filePath)), true);
               // Console.WriteLine($"File '{filePath}' safe.");
            }
        });

        Console.WriteLine($"Total malware files: {cnt}");
        Console.ReadLine();
    }


    static bool CheckFileForMalware(string filePath)
    {
        string hexString = ReadFileAsHexString(filePath);
        string content = HexToString(hexString);

        string[] malwarePatterns =
        {
            "[Dziadulja Apanas]",
            "vectorcall",
            "will not function properly",
            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
            "Rekmmm",
            "½@{÷1¬/\"%",
            "Nfg1QfL4Qd%5Th",
            "W2LPA",
            "%08x_ipc",
            @"HARDWARE\DESCRIPTION\System\CentralProcessor",
            "645FF040-5081-101B-9F08-00AA002F954E",
            "UDx",
            "0123456789abcdefghijklmnopqrstuvwxyz",
            "MSVBVM60",
            "AVbad_array_new_length",
            "PEAUZipMemChain",
            "Srv.exe",
            "<dependency><dependentAssembly>",
            "Delphi-the best. Fuck off all the rest. Neshta 1.0 Made in Belarus",
            "Best regards 2 Tommy Salo",
            "!\"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
        };

        bool isMalware = false;
        foreach (string pattern in malwarePatterns)
        {
            if (content.Contains(pattern))
            {
                isMalware = true;
                break;
            }
        }
        return isMalware;
    }

    static string ReadFileAsHexString(string filePath)
    {
        using (FileStream fileStream = File.OpenRead(filePath))
        {
            byte[] buffer = new byte[fileStream.Length];
            fileStream.Read(buffer, 0, buffer.Length);
            string hexString = BitConverter.ToString(buffer).Replace("-", "");
            return hexString;
        }
    }

    static string HexToString(string hexString)
    {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < hexString.Length; i += 2)
        {
            string hexPair = hexString.Substring(i, 2);
            byte b = Convert.ToByte(hexPair, 16);
            sb.Append((char)b);
        }

        return sb.ToString();
    }
}
